# =============================================================================
# Project: SOLISMC-FILEIO
#
# Convert the loaded configuration into a full header file
#
# Author    Meltwin (github@meltwin.fr)
# Date      14/01/2026 (created 14/01/2026)
# Version   1.0.0
# Copyright Solis Forge | 2026
#           Distributed under MIT License (https://opensource.org/licenses/MIT)
# =============================================================================

from collections.abc import Callable
from functools import singledispatch
from pathlib import Path
from ._reader import DatasetConfig, StreamConfig
from random import randint
import struct
from typing import Any


# =============================================================================
# Generator entrypoint
# =============================================================================
def generate_header(config: DatasetConfig, name: str, output_file: Path) -> None:
    """
    Generate an header file for the given config
    """
    with output_file.open("w+") as handle:
        handle.write(_gen_guard_enter(name))

        # Export values
        handle.write(_add_section("Exporting values"))
        values_strm: dict[str, tuple[int, str]] = {}
        for val_name, val_value in config.values.items():
            length, hex_strm, gen_code = _export_value(
                val_value, val_name, config.cpp_type_
            )
            handle.write(gen_code)
            values_strm[val_name] = (length, hex_strm)

        # Export streams
        handle.write(_add_section("Exporting streams"))
        for strm_name, strm_config in config.streams.items():
            handle.write(
                _export_stream(
                    strm_name,
                    strm_config,
                    config.cpp_type_,
                    values_strm,
                )
            )

        handle.write(_gen_guard_exit())


# =============================================================================
def _add_section(text) -> str:
    """
    Return the string comment for a section in the header file
    """
    line = "// " + "".ljust(77, "=") + "\n"
    return line + f"// {text}\n" + line + "\n"


# =============================================================================
# Preprocessor guards
# =============================================================================
def _gen_guard_enter(name: str) -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    guard = f"SOLIS_DATASET_{name.upper()}_{__randstr(16)}"
    return f"""// AUTOGENERATED FOR SOLISMC_FILEIO
#ifndef {guard}
#define {guard}
#include <array>
#include <cstdint> // IWYU pragma: keep
using UC = unsigned char;

"""


# =============================================================================
def _gen_guard_exit() -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    return "#endif\n"


# =============================================================================
# Helper functions
# =============================================================================
def __randstr(n: int) -> str:
    """
    Generate a random string of given length of alphanum characters
    """

    def __char_map(v: int) -> str:
        if 0 <= v <= 9:
            return str(v)
        if 10 <= v < 36:
            return chr(ord("A") + v - 10)
        return chr(ord("a") + v - 36)

    return "".join([__char_map(randint(0, 9 + 26 + 26)) for _ in range(n)])


# =============================================================================
# Stream exporter
# =============================================================================
def _export_stream(
    name: str,
    strm: StreamConfig,
    ctype: str,
    values_strm: dict[str, tuple[int, str]],
) -> str:
    """Export the given stream"""
    final_strm_length = 0
    final_strm_parts: list[str] = []
    final_values: list[str] = []
    for v in strm.values:
        final_strm_length += values_strm[v][0]
        final_strm_parts.append(values_strm[v][1])
        final_values.append(f"VALUE_{v.upper()}::VALUE")
    final_strm = ",".join(final_strm_parts)

    # Remove some bytes as needed
    if strm.incomplete:
        # Remove one byte of shape ",(UC)'\x00'" (11 chars)
        final_strm = final_strm[:-11]
        final_strm_length -= 1
        final_values[-1] = "0"

    return f"""struct {name.upper()} {{
    static constexpr const UC STREAM[{final_strm_length}] {{{final_strm}}};
    static constexpr unsigned long LENGTH {{{final_strm_length}}};
    static constexpr std::array<{ctype}, {len(final_values)}> VALUES {{{", ".join(final_values)}}};
    static constexpr unsigned long N_VALUES {{{len(final_values)}}};
}};
"""


# =============================================================================
# Values converter
# =============================================================================
_int_cvt: Callable[[int, int], bytes] = lambda v, l: v.to_bytes(
    l // 8, "big", signed=True
)
_float_cvt: Callable[[float, str], bytes] = lambda v, fmt: struct.pack(fmt, v)

VALUE_TO_BYTES: dict[str, Callable[[Any], bytes]] = {
    # Integer types
    "int8_t": lambda v: _int_cvt(v, 8),
    "int16_t": lambda v: _int_cvt(v, 16),
    "int32_t": lambda v: _int_cvt(v, 32),
    "int64_t": lambda v: _int_cvt(v, 64),
    # Floating types
    "float": lambda v: _float_cvt(v, ">f"),
    "double": lambda v: _float_cvt(v, ">d"),
}


# =============================================================================
def __to_uchar_array(t: bytes) -> str:
    return ",".join([f"(UC)'\\x{c:>02x}'" for c in t])


# =============================================================================
@singledispatch
def _export_value(value, name: str, ctype: str) -> tuple[int, str, str]:
    """Export the given value and its char representation"""
    B = VALUE_TO_BYTES[ctype](value)
    strm = __to_uchar_array(B)

    return (
        len(B),
        strm,
        f"""struct VALUE_{name.upper()} {{
    static constexpr {ctype} VALUE {{{value}}};
    static constexpr const UC BYTES[{len(B)}] {{{strm}}};
}};
""",
    )
