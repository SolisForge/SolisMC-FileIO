# =============================================================================
# Project: SOLISMC-FILEIO
#
# Convert the loaded configuration into a full header file
#
# Author    Meltwin (github@meltwin.fr)
# Date      14/01/2026 (created 14/01/2026)
# Version   1.0.0
# Copyright Solis Forge | 2026
#           Distributed under MIT License (https://opensource.org/licenses/MIT)
# =============================================================================

from .ctypes import CType
from functools import singledispatch
from pathlib import Path
from ._reader import DatasetConfig, StreamConfig
from random import randint
from .type_mapping import default_value, fmt_value, to_byte


# =============================================================================
# Generator entrypoint
# =============================================================================
def generate_header(config: DatasetConfig, name: str, output_file: Path) -> None:
    """
    Generate an header file for the given config
    """
    with output_file.open("w+") as handle:
        handle.write(_gen_guard_enter(name, config.includes))

        # Export values
        handle.write(_add_section("Exporting values"))
        values_strm: dict[str, tuple[int, str]] = {}
        for val_name, val_value in config.values.items():
            length, hex_strm, gen_code = _export_value(
                val_value, val_name, config.cpp_type_
            )
            handle.write(gen_code)
            values_strm[val_name] = (length, hex_strm)

        # Export streams
        handle.write(_add_section("Exporting streams"))
        for strm_name, strm_config in config.streams.items():
            handle.write(
                _export_stream(
                    strm_name,
                    strm_config,
                    config.cpp_type_,
                    values_strm,
                )
            )

        handle.write(_gen_guard_exit())


# =============================================================================
def _add_section(text) -> str:
    """
    Return the string comment for a section in the header file
    """
    line = "// " + "".ljust(77, "=") + "\n"
    return line + f"// {text}\n" + line + "\n"


# =============================================================================
# Preprocessor guards
# =============================================================================
def _gen_guard_enter(name: str, additional_includes: list[str]) -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    guard = f"SOLIS_DATASET_{name.upper()}"
    includes = "\n".join(
        [
            f"#include <{include}> // IWYU pragma: keep"
            for include in additional_includes
        ]
    )
    return f"""// AUTOGENERATED FOR SOLISMC_FILEIO
#ifndef {guard}
#define {guard}
#include <array>
{includes}
using UC = unsigned char;

"""


# =============================================================================
def _gen_guard_exit() -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    return "#endif\n"


# =============================================================================
# Stream exporter
# =============================================================================
def _export_stream(
    name: str,
    strm: StreamConfig,
    ctype: CType,
    values_strm: dict[str, tuple[int, str]],
) -> str:
    """Export the given stream"""
    final_strm_length = 0
    final_strm_parts: list[str] = []
    final_values: list[str] = []
    final_values_length: list[str] = []
    for v in strm.values:
        final_strm_length += values_strm[v][0]
        final_strm_parts.append(values_strm[v][1])
        final_values.append(f"VALUE_{v.upper()}::VALUE")
        final_values_length.append(f"VALUE_{v.upper()}::LENGTH")
    final_strm = ",".join(final_strm_parts)

    # Remove some bytes as needed
    if strm.incomplete > 0:
        # Remove one byte of shape ",(UC)'\x00'" (11 chars)
        final_strm = final_strm[: -11 * strm.incomplete]
        final_strm_length -= strm.incomplete
        final_values[-1] = default_value(ctype)

    return f"""struct {name.upper()} {{
    // Byte stream
    static constexpr const UC STREAM[{final_strm_length}] {{{final_strm}}};
    static constexpr unsigned long LENGTH {{{final_strm_length}}};
    
    // Values
    static constexpr unsigned long N_VALUES {{{len(final_values)}}};
    static constexpr std::array<{ctype.value}, {len(final_values)}> VALUES {{{", ".join(final_values)}}};
    static constexpr std::array<std::size_t, {len(final_values_length)}> VALUES_LENGTH {{{", ".join(final_values_length)}}};
}};
"""


# =============================================================================
def __to_uchar_array(t: bytes) -> str:
    return ",".join([f"(UC)'\\x{c:>02x}'" for c in t])


# =============================================================================
def __mk_value_struct(
    _name: str, _v: str, _b: bytes, _l: int, _ctype: CType
) -> tuple[str, str]:
    """
    Return the C++ struct containing the value.
    """
    strm = __to_uchar_array(_b)
    return (
        strm,
        f"""struct VALUE_{_name.upper()} {{
    static constexpr {_ctype.value} VALUE {{{_v}}};
    static constexpr std::size_t LENGTH {{{_l}}};
    static constexpr const UC BYTES[{len(_b)}] {{{strm}}};
}};
""",
    )


# =============================================================================
@singledispatch
def _export_value(value, name: str, ctype: CType) -> tuple[int, str, str]:
    """Export the given value and its char representation"""
    B = to_byte(value, ctype)
    V = fmt_value(value, ctype)

    return (len(B), *__mk_value_struct(name, V, B, len(B), ctype))


@_export_value.register
def _(value: str, name: str, ctype: CType) -> tuple[int, str, str]:
    """Export the given string value"""
    LB = to_byte(len(value), CType.SHORT)
    B = to_byte(value, ctype)
    return (
        len(LB) + len(B),
        *__mk_value_struct(
            name,
            fmt_value(value, ctype),
            LB + B,
            len(B),
            ctype,
        ),
    )
