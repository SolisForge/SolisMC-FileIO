# =============================================================================
# Project: SOLISMC-FILEIO
#
# Convert the loaded configuration into a full header file
#
# Author    Meltwin (github@meltwin.fr)
# Date      14/01/2026 (created 14/01/2026)
# Version   1.0.0
# Copyright Solis Forge | 2026
#           Distributed under MIT License (https://opensource.org/licenses/MIT)
# =============================================================================

from functools import singledispatch
from pathlib import Path
from ._reader import DatasetConfig, StreamConfig
from ._types import ByteStream, _CType, CType, get_value, register_value
from ._types.mapping import (
    default_value,
    fmt_value,
    fmt_value_for_stream,
    fmt_type,
    fmt_type_for_stream,
    to_byte,
)


# =============================================================================
# Generator entrypoint
# =============================================================================
def generate_header(config: DatasetConfig, name: str, output_file: Path) -> None:
    """
    Generate an header file for the given config
    """
    with output_file.open("w+") as handle:
        handle.write(_gen_guard_enter(name, config.includes))

        # Export values
        handle.write(_add_section("Exporting values"))
        for val_name, val_value in config.values.items():

            handle.write(_export_value(val_value, val_name, config.cpp_type_))

        # Export streams
        handle.write(_add_section("Exporting streams"))
        for strm_name, strm_config in config.streams.items():
            handle.write(
                _export_stream(
                    strm_name,
                    strm_config,
                    config.cpp_type_,
                )
            )

        handle.write(_gen_guard_exit())


# =============================================================================
def _add_section(text) -> str:
    """
    Return the string comment for a section in the header file
    """
    line = "// " + "".ljust(77, "=") + "\n"
    return line + f"// {text}\n" + line + "\n"


# =============================================================================
# Preprocessor guards
# =============================================================================
def _gen_guard_enter(name: str, additional_includes: list[str]) -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    guard = f"SOLIS_DATASET_{name.upper()}"
    includes = "\n".join(
        [
            f"#include <{include}> // IWYU pragma: keep"
            for include in additional_includes
        ]
    )
    return f"""// AUTOGENERATED FOR SOLISMC_FILEIO
#ifndef {guard}
#define {guard}
#include <array>
{includes}
using UC = unsigned char;

"""


# =============================================================================
def _gen_guard_exit() -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    return "#endif\n"


# =============================================================================
# Stream exporter
# =============================================================================
def __to_uchar_array(t: bytes) -> str:
    return ",".join([f"(UC)'\\x{c:>02x}'" for c in t])


# =============================================================================
def _export_stream(
    name: str,
    strm: StreamConfig,
    ctype: CType,
) -> str:
    """Export the given stream"""
    stream = ByteStream()
    for v in strm.values:
        value = get_value(v)
        stream.length_ += len(value.stream)
        stream.values_.append(fmt_value_for_stream(f"VALUE_{v.upper()}::VALUE", ctype))
        stream.bytes_ += value.stream
        stream.values_length_.append(f"VALUE_{v.upper()}::LENGTH")

    # Remove some bytes as needed
    if strm.incomplete > 0:
        stream.bytes_ = stream.bytes_[: -strm.incomplete]
        stream.length_ -= strm.incomplete
        stream.values_[-1] = default_value(ctype)

    # Construct final structure
    final_str = __to_uchar_array(stream.bytes_)
    return f"""struct {name.upper()} {{
    // Byte stream
    static constexpr const UC STREAM[{stream.length_}] {{{final_str}}};
    static constexpr unsigned long LENGTH {{{len(stream.bytes_)}}};
    
    // Values
    static constexpr unsigned long N_VALUES {{{len(stream.values_)}}};
    static constexpr std::array<{fmt_type_for_stream(ctype)}, {len(stream.values_length_)}> VALUES {{{", ".join(stream.values_)}}};
    static constexpr std::array<std::size_t, {len(stream.values_length_)}> VALUES_LENGTH {{{", ".join(stream.values_length_)}}};
}};
"""


# =============================================================================
def __mk_value_struct(_name: str, _v: str, _b: bytes, _l: int, _ctype: CType) -> str:
    """
    Return the C++ struct containing the value.
    """
    strm = __to_uchar_array(_b)
    return f"""struct VALUE_{_name.upper()} {{
    static constexpr {fmt_type('VALUE', _ctype, _l)} {{{_v}}};
    static constexpr std::size_t LENGTH {{{_l}}};
    static constexpr const UC BYTES[{len(_b)}] {{{strm}}};
}};
"""


# =============================================================================
@singledispatch
def _export_value(value, name: str, ctype: CType) -> str:
    """Export the given value and its char representation"""
    B = to_byte(value, ctype)
    V = fmt_value(value, ctype)
    register_value(name, ctype, value, B)

    return __mk_value_struct(name, V, B, len(B), ctype)


@_export_value.register
def _(value: str, name: str, ctype: CType) -> str:
    """Export the given string value"""
    LB = to_byte(len(value), ctype=CType(_CType.SHORT))
    B = to_byte(value, ctype)
    register_value(name, ctype, value, LB + B)
    return __mk_value_struct(
        name,
        fmt_value(value, ctype),
        LB + B,
        len(B),
        ctype,
    )


@_export_value.register
def _(value: list, name: str, ctype: CType) -> str:
    """
    Value export for lists
    """
    # Get bytes for array length
    B = to_byte(len(value), CType(_CType.INT))

    # Extract bytes for all elements
    for v in value:
        B += to_byte(v, ctype.list_spec)

    register_value(name, ctype, value, B)
    return __mk_value_struct(
        name,
        fmt_value(value, ctype),
        B,
        len(value),
        ctype,
    )
