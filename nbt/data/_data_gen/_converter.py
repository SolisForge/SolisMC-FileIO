# =============================================================================
# Project: SOLISMC-FILEIO
#
# Convert the loaded configuration into a full header file
#
# Author    Meltwin (github@meltwin.fr)
# Date      14/01/2026 (created 14/01/2026)
# Version   1.0.0
# Copyright Solis Forge | 2026
#           Distributed under MIT License (https://opensource.org/licenses/MIT)
# =============================================================================

from functools import singledispatch
from pathlib import Path
from ._reader import DatasetConfig, StreamConfig
from random import randint


# =============================================================================
# Generator entrypoint
# =============================================================================
def generate_header(config: DatasetConfig, name: str, output_file: Path) -> None:
    """
    Generate an header file for the given config
    """
    with output_file.open("w+") as handle:
        handle.write(_gen_guard_enter(name))

        # Export values
        handle.write(_add_section("Exporting values"))
        values_strm: dict[str, list[str]] = {}
        for val_name, val_value in config.values.items():
            hex_strm, gen_code = _export_value(val_value, val_name, config.cpp_type_)
            handle.write(gen_code)
            values_strm[val_name] = hex_strm

        # Export streams
        handle.write(_add_section("Exporting streams"))
        for strm_name, strm_config in config.streams.items():
            handle.write(
                _export_stream(
                    strm_name,
                    strm_config,
                    config.cpp_type_,
                    values_strm,
                )
            )

        handle.write(_gen_guard_exit())


# =============================================================================
def _add_section(text) -> str:
    """
    Return the string comment for a section in the header file
    """
    line = "// " + "".ljust(77, "=") + "\n"
    return line + f"// {text}\n" + line + "\n"


# =============================================================================
# Preprocessor guards
# =============================================================================
def _gen_guard_enter(name: str) -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    guard = f"SOLIS_DATASET_{name.upper()}_{__randstr(16)}"
    return f"""// AUTOGENERATED FOR SOLISMC_FILEIO
#ifndef {guard}
#define {guard}
#include <cstdint>
#include <array>
"""


# =============================================================================
def _gen_guard_exit() -> str:
    """
    Generate the preprocessor guard at the beginning of the file.
    """
    return "#endif\n"


# =============================================================================
# Helper functions
# =============================================================================
def __randstr(n: int) -> str:
    """
    Generate a random string of given length of alphanum characters
    """

    def __char_map(v: int) -> str:
        if 0 <= v <= 9:
            return str(v)
        if 10 <= v < 36:
            return chr(ord("A") + v - 10)
        return chr(ord("a") + v - 36)

    return "".join([__char_map(randint(0, 9 + 26 + 26)) for _ in range(n)])


# =============================================================================
def __to_uchar_array(t: list[str]) -> str:
    return ",".join([f"(unsigned char)'{c}'" for c in t])


# =============================================================================
# Stream exporter
# =============================================================================
def _export_stream(
    name: str,
    strm: StreamConfig,
    ctype: str,
    values_strm: dict[str, list[str]],
) -> str:
    """Export the given stream"""
    final_strm: list[str] = []
    final_values: list[str] = []
    for v in strm.values:
        final_strm += values_strm[v]
        final_values.append(f"VALUE_{v.upper()}::VALUE")

    if strm.incomplete:
        final_strm.pop()
        final_values[-1] = "0"

    return f"""struct {name.upper()} {{
    static constexpr const unsigned char STREAM[{len(final_strm)}] {{{__to_uchar_array(final_strm)}}};
    static constexpr unsigned long LENGTH {{{len(final_strm)}}};
    static constexpr std::array<{ctype}, {len(final_values)}> VALUES {{{", ".join(final_values)}}};
    static constexpr unsigned long N_VALUES {{{len(final_values)}}};
}};
"""


# =============================================================================
# Values converter
# =============================================================================
@singledispatch
def _export_value(value, name: str, ctype: str) -> tuple[list[str], str]:
    """Export the given value and its char representation"""
    ...


# =============================================================================
@_export_value.register
def _(value: int, name: str, ctype: str) -> tuple[list[str], str]:
    """Export the int value"""
    length = {
        "int8_t": 8,
        "int16_t": 16,
        "int32_t": 32,
        "int64_t": 64,
    }[ctype] // 8
    B = value.to_bytes(length, "big", signed=True)
    stream = [f"\\x{b:>02x}" for b in B]

    return (
        stream,
        f"""struct VALUE_{name.upper()} {{
    static constexpr {ctype} VALUE {{{value}}};
    static constexpr const unsigned char BYTES[{len(stream)}] {{{__to_uchar_array(stream)}}};
}};
""",
    )
